<!DOCTYPE html>

<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		
		<link rel="stylesheet" type="text/css" href="style.css">
	</head>
	<body>
		<canvas id="canvas"></canvas>
		<div id="filedrop">Drop files here</div>
		
		<!-- Script inclusion -->
		<script src="engine/core.js"></script>

        <!-- Core components -->
		<script src="engine/camera.js"></script>
		<script src="engine/light.js"></script>
		<script src="engine/model.js"></script>

		<script src="engine/mesh.js"></script>
		<script src="engine/geometry.js"></script>

		<script src="engine/utility.js"></script>
		<script src="engine/scene.js"></script>
		<script src="engine/webgl.js"></script>
		<script src="engine/shader.js"></script>
		<script src="engine/renderer.js"></script>
		<script src="engine/material.js"></script>
		<script src="engine/model.js"></script>
		<script src="engine/quaternion.js"></script>
		<script src="engine/models.js"></script>
		<script src="engine/filehandler.js"></script>
		<script src="engine/events.js"></script>
	</body>
</html>





<!-- Vertex shader -->
<script id="vertex_shader" type="noscript">#version 300 es
in vec4 a_position;
in vec4 a_color;

uniform mat4 model;
uniform mat4 perspective;
uniform mat4 view;

out vec4 fragColor;

void main() {
	gl_Position = perspective * view * model * a_position;
	fragColor = a_color;
}
</script>





<!-- Fragment shader -->
<script id="fragment_shader" type="noscript">#version 300 es
precision mediump float;
in vec4 fragColor;

out vec4 outColor;

void main() {
	outColor = fragColor;
}
</script>


<script id="test-shader" type="noscript">
#ifdef COMPILE_FRAGMENT
    #define varying in
    
    precision mediump float;
#endif

#ifdef COMPILE_VERTEX
    #define varying out

    uniform mat4 uModelViewMatrix;
    uniform mat4 uProjectionMatrix;

    in vec3 iPosition;

    #ifdef VERTEX_COLORS
        in vec3 iColor;
        #endif

    #ifdef NORMALS
        in vec3 iNormal;
    #endif

    #if defined(DIFFUSEMAP) || defined(NORMALMAP)
        in vec2 vTexCoord;
    #endif

    #ifdef NORMALMAP
        in vec3 iTangent;
    #endif

#endif

#ifdef VERTEX_COLORS
    varying vec3 vColor;
#endif

#if defined(DIFFUSEMAP) || defined(NORMALMAP)
    varying vec2 vTexCoord;
#endif

#ifdef NORMALS
    varying vec3 vNormal;
#endif

#ifdef NORMALMAP
    varying vec3 vTangent;
#endif

///////////////////////////////////////////////////////////////////////////////
// Vertex shader

#ifdef COMPILE_VERTEX

void main()
{
    vec4 pos = uProjectionMatrix * uModelViewMatrix * vec4(iPosition, 1.0);
    // pos = uProjectionMatrix * pos;
    // vec4 pos = vec4(iPosition, 1.0);
    //vec4 pos = uModelViewMatrix * vec4(iPosition, 1.0);

    pos.z *= 0.1;

    #ifdef VERTEX_COLORS
        vColor = iColor;
    #endif

    #if defined(DIFFUSEMAP) || defined(NORMALMAP)
        vTexCoord = iTexCoord;
    #endif

    gl_Position = pos;
}

#endif

#ifdef COMPILE_FRAGMENT

uniform sampler2D sDiffuse;
uniform sampler2D sSpecular;
uniform sampler2D sAmbient;
uniform sampler2D sNormalMap;
uniform sampler2D sHeightMap;
uniform sampler2D sEmission;
uniform sampler2D sEnvironment;

uniform vec4 uDiffuseColor;
uniform vec4 uSpecularColor;
uniform vec3 uEmission;

out vec4 fColor;

vec4 GetDiffuse()
{
    return uDiffuseColor;
}

vec3 GetSpecular()
{
    return vec3(0.1, 0.1, 0.1);
}

vec3 GetAmbient()
{
    return vec3(0.0, 0.0, 0.0);
}

vec3 GetEmission()
{
    return vec3(0.0, 0.0, 0.0);
}

///////////////////////////////////////////////////////////////////////////////
// Fragment shader

void main()
{
    vec4 col;

    #ifdef DIFFUSEMAP
        col = texture2D(sDiffuse, vTexCoord);
    #else
        col = vec4(1.0, 1.0, 1.0, 1.0);
    #endif

    #ifdef VERTEX_COLORS
        col.rgb *= vColor;
    #else
        col *= vec4(0.0, 1.0, 1.0, 1.0);
    #endif

    col *= GetDiffuse();
    col.rgb += GetSpecular();
    col.rgb += GetEmission();
    col.rgb += GetAmbient();

    fColor = col;
}

#endif
</script>


<script>
// Test run script
function testRun() {
	// Setting up model program and vao is done when model is loaded
	// Model loading starts after gl has been initialized!!!
	engine.models.cube.program = engine.gl.program.default;
	engine.models.cube.vao = webgl.createModelVaoAndBuffers(engine.gl, engine.models.cube);
	// Demo object. Objects refer to a model
	// Transform is a property of a demo object, not a model's
	obj = {};
	obj.model = engine.models.cube;
	
    engine.builtinMesh = {
        "ColorCube": engine.models.cube,
    };
	engine.gl.view = mat4.invert(mat4.translate(0, 0, -5));
	
	// asd();
    sceneTest();
}

function asd() {
	requestAnimationFrame(asd);
	
	obj.transform = mat4.multiply(mat4.rotateY(Date.now() * 0.001), mat4.rotateX(Date.now() * 0.003));
	
	webgl.drawObjectModel(engine.gl, obj);
}

function buildTestMesh(positions, colors, indices) {

    if (positions.length != colors.length) {
        console.log("Bad lengths on vertex attributes");
        return null;
    }

    if ((positions.length % 3) != 0) {
        console.log("Uneven vertex attribute length");
        return null;
    }

    let vCount = positions.length / 3;
    let vSize = 6; // sizeof(position) + sizeof(color) 

    let vBuff = new Float32Array(vCount * vSize);

    for (let i = 0; i < vCount; ++i) {
        let offset = i * vSize;

        vBuff[offset + 0] = positions[i * 3 + 0];
        vBuff[offset + 1] = positions[i * 3 + 1];
        vBuff[offset + 2] = positions[i * 3 + 2];

        vBuff[offset + 3] = colors[i * 3 + 0];
        vBuff[offset + 4] = colors[i * 3 + 1];
        vBuff[offset + 5] = colors[i * 3 + 2];
    }

    let iBuff = new Uint16Array(indices);

    let attrs = [
        new MeshAttribute("position", 0, 3),
        new MeshAttribute("color", 3, 3),
    ];
    

    return Mesh.fromData(vBuff, iBuff, attrs);
}

function sceneTest() {
    engine.renderer = new Renderer(engine.gl);

    let mesh = buildTestMesh(
        engine.models.cube.vertices,
        engine.models.cube.colors,
        engine.models.cube.indices
    );

    let shader = new ShaderSource("TestShader",
        document.getElementById("test-shader").innerHTML);

    let scene = new Scene();

    let cubeNode = scene.createChild("Cube");
    cubeNode.worldTransform = mat4.identity();

    let cube = cubeNode.createComponent(Model);
    cube.mesh = mesh;
    cube.material = new Material();
    cube.material.shader = shader;
    cube.material.defines = new Map([["VERTEX_COLORS", null]]);
    cube.material.diffuseColor = Color.gray;

    let camNode = scene.createChild("Camera");
	camNode.worldTransform = mat4.translate(0, 0, -5.0);

    let camera = camNode.createComponent(Camera);
    camera.fieldOfView = 90.0;

    requestAnimationFrame(function update() {
        requestAnimationFrame(update);

        cubeNode.worldTransform = mat4.multiply(
            mat4.rotateY(Date.now() * 0.0001),
            mat4.rotateX(Date.now() * 0.0003)
        );

        // scene.updateHierarchy(false);
        scene.update();

        engine.renderer.resetPerformance();
        engine.renderer.renderScene(scene, camera);

    });
}

</script>
