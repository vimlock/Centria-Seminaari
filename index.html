<!DOCTYPE html>

<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		
		<link rel="stylesheet" type="text/css" href="style.css">
	</head>
	<body>
		<canvas id="canvas"></canvas>
		<div id="filedrop">Drop files here</div>

        <div id="render-statistics">
        </div>
		
		<!-- Script inclusion -->
		<script src="engine/core.js"></script>

        <!-- Core components -->
		<script src="engine/camera.js"></script>
		<script src="engine/light.js"></script>
		<script src="engine/model.js"></script>

		<script src="engine/mesh.js"></script>
		<script src="engine/geometry.js"></script>

		<script src="engine/utility.js"></script>
		<script src="engine/scene.js"></script>
		<script src="engine/webgl.js"></script>
		<script src="engine/shader.js"></script>
		<script src="engine/renderer.js"></script>
		<script src="engine/material.js"></script>
		<script src="engine/model.js"></script>
		<script src="engine/quaternion.js"></script>
		<script src="engine/models.js"></script>
		<script src="engine/filehandler.js"></script>
		<script src="engine/events.js"></script>
		
		<script src="engine/mesh.js"></script>
		<script src="engine/model.js"></script>
		<script src="engine/resources.js"></script>
		<script src="engine/geometry.js"></script>
		<script src="engine/light.js"></script>
		<script src="engine/material.js"></script>
		<script src="engine/quaternion.js"></script>
		<script src="engine/renderer.js"></script>
		<script src="engine/shader.js"></script>
	</body>
</html>





<!-- Vertex shader -->
<script id="vertex_shader" type="noscript">#version 300 es
in vec4 a_position;
in vec4 a_color;

uniform mat4 model;
uniform mat4 perspective;
uniform mat4 view;

out vec4 fragColor;

void main() {
	gl_Position = perspective * view * model * a_position;
	fragColor = a_color;
}
</script>





<!-- Fragment shader -->
<script id="fragment_shader" type="noscript">#version 300 es
precision mediump float;
in vec4 fragColor;

out vec4 outColor;

void main() {
	outColor = fragColor;
}
</script>


<script id="test-shader" type="noscript">
#ifdef COMPILE_FRAGMENT
    #define varying in
    
    precision mediump float;
#endif

#ifdef COMPILE_VERTEX
    #define varying out

    uniform mat4 uModelViewMatrix;
    uniform mat4 uModelMatrix;
    uniform mat4 uProjectionMatrix;

    uniform mat4 uViewProjectionMatrix;
    uniform mat4 uViewMatrix;

    in vec3 iPosition;

    #ifdef VERTEX_COLORS
        in vec3 iColor;
        #endif

    #ifdef NORMALS
        in vec3 iNormal;
    #endif

    #if defined(DIFFUSEMAP) || defined(NORMALMAP)
        in vec2 vTexCoord;
    #endif

    #ifdef NORMALMAP
        in vec3 iTangent;
    #endif

    #ifdef INSTANCING
        in mat4 iInstanceModelMatrix;
    #endif

#endif

#ifdef VERTEX_COLORS
    varying vec3 vColor;
#endif

#if defined(DIFFUSEMAP) || defined(NORMALMAP)
    varying vec2 vTexCoord;
#endif

#ifdef NORMALS
    varying vec3 vNormal;
#endif

#ifdef NORMALMAP
    varying vec3 vTangent;
#endif

varying vec3 vWorldPos;

///////////////////////////////////////////////////////////////////////////////
// Vertex shader

#ifdef COMPILE_VERTEX

void main()
{
    #ifdef INSTANCING
        vec4 pos = iInstanceModelMatrix * vec4(iPosition, 1.0);
        vWorldPos = pos.xyz;

        pos = uViewProjectionMatrix * pos;

        #ifdef NORMALS
            vNormal = normalize((mat3(iInstanceModelMatrix) * iNormal));
        #endif

    #else
        vec4 pos = uModelViewMatrix * vec4(iPosition, 1.0);
        pos = uProjectionMatrix * pos;
        vWorldPos = (uModelMatrix * vec4(iPosition, 1.0)).xyz;

        #ifdef NORMALS
            vNormal = normalize((mat3(uModelViewMatrix) * iNormal));
        #endif
    #endif

    #ifdef VERTEX_COLORS
        vColor = iColor;
    #endif


    #if defined(DIFFUSEMAP) || defined(NORMALMAP)
        vTexCoord = iTexCoord;
    #endif

    gl_Position = pos;
}

#endif

#ifdef COMPILE_FRAGMENT

struct Light {
    vec3 position;
    vec4 color;
    float range;
};


uniform sampler2D sDiffuse;
uniform sampler2D sSpecular;
uniform sampler2D sAmbient;
uniform sampler2D sNormalMap;
uniform sampler2D sHeightMap;
uniform sampler2D sEmission;
uniform sampler2D sEnvironment;

uniform vec4 uDiffuseColor;
uniform vec4 uSpecularColor;
uniform vec4 uAmbientColor;
uniform vec3 uEmission;

#ifdef LIGHTS
uniform Light uLights[MAX_LIGHTS];
uniform vec3 uViewForward;
uniform vec3 uViewPosition;
#endif

out vec4 fColor;

vec4 GetLighting(vec4 diffColor)
{
    vec4 lighting = vec4(0.0, 0.0, 0.0, 1.0);
    vec3 normal = normalize(vNormal);

    for (int i = 0; i < MAX_LIGHTS; ++i) {
        vec3 surfaceToLightDelta = uLights[i].position - vWorldPos;
        vec3 surfaceToLight = normalize(surfaceToLightDelta); 
        vec3 surfaceToView = normalize(uViewPosition - vWorldPos);
        
        vec3 halfVector = normalize(surfaceToLight + surfaceToView);

        float diffFactor = max(dot(normal, surfaceToLight), 0.0);
        float specFactor = 0.0;
        if (diffFactor > 0.0)
            specFactor = pow(max(dot(normal, halfVector), 0.0), 300.0);

        float atten = clamp(1.0 - uLights[i].range / length(surfaceToLightDelta), 0.0, 1.0);
        atten = 1.0 - pow(atten, 2.0);

        lighting.rgb += (diffColor.rgb * uLights[i].color.rgb * diffFactor +
                        uSpecularColor.rgb * specFactor * atten) * uLights[i].color.a * atten;

        // lighting.rgb += diffFactor * vec3(0.1, 0.1, 0.1);
        // lighting.rgb += specFactor * vec3(1.0, 1.0, 1.0);
    }

    return lighting + uAmbientColor;
}

vec4 GetDiffuse()
{

    return uDiffuseColor;
}

vec3 GetSpecular()
{
    return vec3(0.1, 0.1, 0.1);
}

vec3 GetAmbient()
{
    return uAmbientColor.rgb;
}

vec3 GetEmission()
{
    return vec3(0.0, 0.0, 0.0);
}

///////////////////////////////////////////////////////////////////////////////
// Fragment shader

void main()
{
    vec4 col;

    #ifdef DIFFUSEMAP
        col = texture2D(sDiffuse, vTexCoord);
    #else
        col = vec4(1.0, 1.0, 1.0, 1.0);
    #endif

    #ifdef VERTEX_COLORS
        col.rgb *= vColor;
    #else
        col *= vec4(0.0, 1.0, 1.0, 1.0);
    #endif

    col.rgb = GetLighting(col).rgb;

    fColor = col;
}

#endif
</script>


<script>
// Test run script
function testRun() {
	// Setting up model program and vao is done when model is loaded
	// Model loading starts after gl has been initialized!!!
	engine.models.cube.program = engine.gl.program.default;
	engine.models.cube.vao = webgl.createModelVaoAndBuffers(engine.gl, engine.models.cube);
	// Demo object. Objects refer to a model
	// Transform is a property of a demo object, not a model's
	obj = {};
	obj.model = engine.models.cube;
	
    engine.builtinMesh = {
        "ColorCube": engine.models.cube,
    };
	engine.gl.view = mat4.invert(mat4.translate(0, 0, -5));
	
	// asd();
    sceneTest();
}

function asd() {
	requestAnimationFrame(asd);
	
	obj.transform = mat4.multiply(mat4.rotateY(Date.now() * 0.001), mat4.rotateX(Date.now() * 0.003));
	
	webgl.drawObjectModel(engine.gl, obj);
}

function buildTestMesh(positions, colors, normals, indices) {

    if (positions.length != colors.length || positions.length != normals.length) {
        console.log("Uneven lengths on vertex attributes");
        return null;
    }

    if ((positions.length % 3) != 0) {
        console.log("Vertex attribute lengths not multiply of 3");
        return null;
    }

    let vCount = positions.length / 3;
    let vSize = 9; // sizeof(position) + sizeof(color) + sizeof(normal)

    let vBuff = new Float32Array(vCount * vSize);

    for (let i = 0; i < vCount; ++i) {
        let offset = i * vSize;

        vBuff[offset + 0] = positions[i * 3 + 0];
        vBuff[offset + 1] = positions[i * 3 + 1];
        vBuff[offset + 2] = positions[i * 3 + 2];

        vBuff[offset + 3] = colors[i * 3 + 0];
        vBuff[offset + 4] = colors[i * 3 + 1];
        vBuff[offset + 5] = colors[i * 3 + 2];

        vBuff[offset + 6] = normals[i * 3 + 0];
        vBuff[offset + 7] = normals[i * 3 + 1];
        vBuff[offset + 8] = normals[i * 3 + 2];
    }

    let iBuff = new Uint16Array(indices);

    let attrs = [
        new MeshAttribute("position", 0, 3),
        new MeshAttribute("color", 3, 3),
        new MeshAttribute("normal", 6, 3),
    ];
    

    return Mesh.fromData(vBuff, iBuff, attrs);
}

function displayStatics(performance) {
    let div = document.getElementById("render-statistics");

    let html = 
        "<p>FPS: " + parseInt(performance.fps) + "</p>" +
        "<p>Vertices: " + performance.vertices + "</p>" +
        "<p>Draw Calls: " + performance.numDrawCalls + "</p>" +
        "<p>Lights: " + performance.numLights + "</p>" +
        "<p>Batches: " + performance.batches + "</p>";

    div.innerHTML = html;
}

function random(scale) {
    return ((Math.random() * 2.0) - 1.0) * scale;
}

function spawnCubes(scene, mesh, material, num)
{
    for (let i = 0; i < num; ++i) {
        let cubeNode = scene.createChild("Cube");

        let scale = 0.75 + random(0.7);

        cubeNode.worldTransform = mat4.multiply(
            mat4.translate(random(50.0), random(50.0), random(50.0)),
            mat4.scale(scale, scale, scale) 
        );

        cubeNode.worldTransform = mat4.multiply(
                cubeNode.worldTransform,
                mat4.rotateX(random(360.0))
        );

        cubeNode.worldTransform = mat4.multiply(
                cubeNode.worldTransform,
                mat4.rotateY(random(360.0))
        );

        let cube = cubeNode.createComponent(Model);
        cube.mesh = mesh;
        cube.material = material;
    }
}


function initInput() {

    let inputKeys = ["w", "a", "s", "d", "e", "q"];

    let input = {
    };

    inputKeys.forEach(function(value) {
        input[value] = false;
    });

    input["MouseX"] = undefined;
    input["MouseY"] = undefined;

    input["MouseDeltaX"] = 0.0;
    input["MouseDeltaY"] = 0.0;

    window.addEventListener("keydown", function(ev) {
        if (ev.key in input) {
            input[ev.key] = true;
        }

    }, false);

    window.addEventListener("keyup", function(ev) {
        if (ev.key in input) {
            input[ev.key] = false;
        }

    }, false);

    window.addEventListener("mousemove", function(ev) {
        if (input["MouseX"] === undefined) {
            input["MouseX"] = ev.screenX;
            input["MouseX"] = ev.screenY;
        }
        else {
            input["MouseDeltaX"] = ev.screenX - input["MouseX"];
            input["MouseDeltaY"] = ev.screenY - input["MouseY"];

            input["MouseX"] = ev.screenX;
            input["MouseY"] = ev.screenY;
        }

    }, false);

    return input;
}

function updateCamera(camNode, timeDelta) {

    let dz = 0.0;
    let dx = 0.0;
    let dy = 0.0;

    if (engine.input["w"]) { dz += 1.0; }
    if (engine.input["s"]) { dz -= 1.0; }

    if (engine.input["d"]) { dx -= 1.0; }
    if (engine.input["a"]) { dx += 1.0; }

    if (engine.input["e"]) { dy -= 1.0; }
    if (engine.input["q"]) { dy += 1.0; }

    const speed = 0.01;

    dz *= timeDelta * speed;
    dx *= timeDelta * speed;
    dy *= timeDelta * speed;

    let d = vec3.add(
        vec3.scale(camNode.forward, dz),
        vec3.scale(camNode.left, dx)
    );

    d = vec3.add(d, vec3.scale(camNode.up, dy));

    let position = vec3.add(camNode.worldPosition, d);

    camNode.worldTransform[12] = 0.0;
    camNode.worldTransform[13] = 0.0;
    camNode.worldTransform[14] = 0.0;

    camNode.worldTransform = mat4.multiply(
        camNode.worldTransform, mat4.translate(position[0], position[1], position[2])
    );

}

function sceneTest() {
    engine.renderer = new Renderer(engine.gl);
    engine.renderer.performance.fps = 0.0;
    engine.input = initInput();

    let scene = new Scene();
    scene.ambientColor = new Color(0.1, 0.01, 0.01, 1.0);

    let mesh = buildTestMesh(
        engine.models.cube.vertices,
        engine.models.cube.colors,
        engine.models.cube.normals,
        engine.models.cube.indices
    );

    let material = new Material();

    material.shader = new ShaderSource("TestShader",
        document.getElementById("test-shader").innerHTML);

    material.defines = new Map([
        // ["VERTEX_COLORS", null],
        ["NORMALS", null],
        ["LIGHTS", null],
        ["INSTANCING", null],
    ]);

    spawnCubes(scene, mesh, material, 10000);

    let cubeNode = scene.createChild("Cube");
    cubeNode.worldTransform = mat4.identity();

    let cube = cubeNode.createComponent(Model);
    cube.mesh = mesh;
    cube.material = material;

    let camNode = scene.createChild("Camera");
	camNode.worldTransform = mat4.translate(0, 0, -5.0);

    let camera = camNode.createComponent(Camera);
    camera.fieldOfView = 90.0;

    let lightNode = scene.createChild("Light");
    lightNode.worldTransform = mat4.translate(30, 30, -30);
    let light = lightNode.createComponent(Light);
    light.color = new Color(0.4, 0.4, 1.0, 1.2);

    lightNode = scene.createChild("Light2");
    lightNode.worldTransform = mat4.translate(-30, -30, 30);
    light = lightNode.createComponent(Light);
    light.color = new Color(0.5, 1.0, 0.5, 1.2);

    let prevFrameTime = Date.now();

    requestAnimationFrame(function update() {
        let currentFrameTime = Date.now();
        let timeDelta = currentFrameTime - prevFrameTime;

        let fps = 1.0 / Math.max(timeDelta * 0.001, 0.001);

        requestAnimationFrame(update);

        cubeNode.worldTransform = mat4.multiply(
            mat4.rotateY(Date.now() * 0.00001),
            mat4.rotateX(Date.now() * 0.00001)
        );

        cubeNode.worldTransform = mat4.translate(0.0, 0, 0),

        // scene.updateHierarchy(false);
        scene.update();

        updateCamera(camNode, timeDelta);

        engine.renderer.resetPerformance();
        engine.renderer.renderScene(scene, camera);

        engine.renderer.performance.fps = engine.renderer.performance.fps * 0.99 + fps * 0.01;
        //engine.renderer.performance.fps = fps;
        displayStatics(engine.renderer.performance);

        prevFrameTime = currentFrameTime;
    });
}

</script>
