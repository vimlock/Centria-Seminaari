<!DOCTYPE html>

<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		
		<link rel="stylesheet" type="text/css" href="style.css">
	</head>
	<body>
		<canvas id="canvas"></canvas>
		<div id="filedrop">Drop files here</div>

        <div id="render-statistics">
        </div>
		
		<!-- Script inclusion -->
		<script src="engine/core.js"></script>

        <!-- Core components -->
		<script src="engine/serialize.js"></script>
		<script src="engine/component.js"></script>

		<script src="engine/camera.js"></script>
		<script src="engine/light.js"></script>
		<script src="engine/model.js"></script>
		<script src="engine/environmentmap.js"></script>

		<script src="engine/resource.js"></script>
		<script src="engine/cubemap.js"></script>
		<script src="engine/mesh.js"></script>
		<script src="engine/file.js"></script>
		<script src="engine/geometry.js"></script>

		<script src="engine/utility.js"></script>
		<script src="engine/scene.js"></script>
		<script src="engine/webgl.js"></script>
		<script src="engine/shader.js"></script>
		<script src="engine/debug.js"></script>
		<script src="engine/renderview.js"></script>
		<script src="engine/renderer.js"></script>
		<script src="engine/material.js"></script>
		<script src="engine/model.js"></script>
		<script src="engine/quaternion.js"></script>
		<script src="engine/models.js"></script>
		<script src="engine/filehandler.js"></script>
		<script src="engine/events.js"></script>
		
		<script src="engine/mesh.js"></script>
		<script src="engine/model.js"></script>
		<script src="engine/resources.js"></script>
		<script src="engine/geometry.js"></script>
		<script src="engine/light.js"></script>
		<script src="engine/material.js"></script>
		<script src="engine/quaternion.js"></script>
		<script src="engine/renderer.js"></script>
		<script src="engine/shader.js"></script>
	</body>
</html>





<!-- Vertex shader -->
<script id="vertex_shader" type="noscript">#version 300 es
in vec4 a_position;
in vec4 a_color;

uniform mat4 model;
uniform mat4 perspective;
uniform mat4 view;

out vec4 fragColor;

void main() {
	gl_Position = perspective * view * model * a_position;
	fragColor = a_color;
}
</script>





<!-- Fragment shader -->
<script id="fragment_shader" type="noscript">#version 300 es
precision mediump float;
in vec4 fragColor;

out vec4 outColor;

void main() {
	outColor = fragColor;
}
</script>

<script id="debug-shader" type="noscript">
#ifdef COMPILE_FRAGMENT
    #define varying in
    
    precision mediump float;
#endif

#ifdef COMPILE_VERTEX
    #define varying out

    uniform mat4 uViewProjectionMatrix;

    in vec3 iPosition;
    in vec4 iColor;
#endif

varying vec4 vColor;

#ifdef COMPILE_VERTEX

uniform vec4 uTint;

///////////////////////////////////////////////////////////////////////////////
// Vertex shader

void main() {
    vColor = iColor * uTint;
    gl_Position = uViewProjectionMatrix * vec4(iPosition, 1.0);
}

#endif

#ifdef COMPILE_FRAGMENT

out vec4 fColor;

///////////////////////////////////////////////////////////////////////////////
// Fragment shader

void main() {
    fColor = vColor;
}

#endif

</script>


<script id="test-shader" type="noscript">
precision mediump float;

#ifdef COMPILE_FRAGMENT
    #define varying in
#endif

#if defined(DIFFUSEMAP) || defined(SPECMAP) || defined(AMBIENTMAP) || defined(NORMALMAP)
    #define TEXCOORDS
#endif

#if defined(EMISSIONMAP) && !defined(TEXCOORDS)
    #define TEXCOORDS
#endif

#if defined(NORMALMAP)
    #define TANGENTS
#endif

#if defined(DIFFUSEMAP) || defined(SPECMAP) || defined(AMBIENTMAP) || defined(NORMALMAP)
    #define TEXCOORDS
#endif

#if defined(EMISSIONMAP) && !defined(TEXCOORDS)
    #define TEXCOORDS
#endif

#if defined(NORMALMAP)
    #define TANGENTS
#endif

#ifdef COMPILE_VERTEX
    #define varying out

    uniform mat4 uModelViewMatrix;
    uniform mat4 uModelMatrix;
    uniform mat4 uProjectionMatrix;

    uniform mat4 uViewProjectionMatrix;
    uniform mat4 uViewMatrix;

    in vec3 iPosition;

    #ifdef VERTEX_COLORS
        in vec3 iColor;
    #endif

    #ifdef NORMALS
        in vec3 iNormal;
    #endif

    #ifdef TEXCOORDS
        in vec2 iTexCoord;
    #endif

    #ifdef NORMALMAP
        in vec3 iTangent;
        in vec3 iBitangent;
    #endif

    #ifdef INSTANCING
        in mat4 iInstanceModelMatrix;
    #endif

    #ifdef ENVIRONMENTMAP
        uniform vec3 uViewPosition;
    #endif

#endif

#if __VERSION__ >= 130
    #define texture2D texture
#endif

#ifdef VERTEX_COLORS
    varying vec3 vColor;
#endif

#ifdef TEXCOORDS
    varying vec2 vTexCoord;
#endif

#ifdef NORMALS
    varying vec3 vNormal;
#endif

#ifdef NORMALMAP
    varying vec3 vTangent;
    varying vec3 vBitangent;
#endif

#ifdef ENVIRONMENTMAP
    varying vec3 vReflection;
#endif

varying vec3 vWorldPos;

///////////////////////////////////////////////////////////////////////////////
// Vertex shader

#ifdef COMPILE_VERTEX

void main()
{
    #ifdef INSTANCING
        vec4 pos = iInstanceModelMatrix * vec4(iPosition, 1.0);
        vWorldPos = pos.xyz;

        pos = uViewProjectionMatrix * pos;

        #ifdef NORMALS
            vec3 normal = normalize((mat3(iInstanceModelMatrix) * iNormal));
        #endif

    #else
        vec4 pos = uModelViewMatrix * vec4(iPosition, 1.0);
        pos = uProjectionMatrix * pos;
        vWorldPos = (uModelMatrix * vec4(iPosition, 1.0)).xyz;

        #ifdef NORMALS
            vec3 normal = normalize((mat3(uModelViewMatrix)) * iNormal);
        #endif
    #endif

    #ifdef NORMALS
        vNormal = normal;
    #endif

    #ifdef VERTEX_COLORS
        vColor = iColor;
    #endif

    #ifdef TEXCOORDS
        vTexCoord = iTexCoord;
    #endif

    #ifdef NORMALMAP
        vTangent = iTangent;
        vBitangent = iBitangent;
    #endif

    #ifdef ENVIRONMENTMAP
        vReflection = vWorldPos - uViewPosition;
    #endif

    gl_Position = pos;
}

#endif

#ifdef COMPILE_FRAGMENT

struct Light {
    vec3 position;
    vec4 color;
    float range;
};


uniform sampler2D sDiffuseMap;
uniform sampler2D sSpecularMap;
uniform sampler2D sAmbientMap;
uniform sampler2D sNormalMap;
uniform sampler2D sHeightMap;
// uniform sampler2D sEmissionMap;
uniform samplerCube sEnvironmentMap;

uniform vec4 uDiffuseColor;
uniform vec4 uSpecularColor;
uniform vec4 uAmbientColor;
uniform vec3 uEmission;

#ifdef LIGHTS
uniform Light uLights[MAX_LIGHTS];
uniform vec3 uViewForward;
uniform vec3 uViewPosition;
#endif

#ifdef FOG

// uFogParams.x: fogStart
// uFogParams.y: fogEnd
uniform vec2 uFogParams;
uniform vec3 uFogColor;

#endif

out vec4 fColor;

#ifdef LIGHTS

vec4 GetLighting(vec3 normal, vec4 diffColor, vec4 specColor)
{
    vec4 lighting = vec4(0.0, 0.0, 0.0, 1.0);

    for (int i = 0; i < MAX_LIGHTS; ++i) {
        vec3 surfaceToLightDelta = uLights[i].position - vWorldPos;
        vec3 surfaceToLight = normalize(surfaceToLightDelta); 
        vec3 surfaceToView = normalize(uViewPosition - vWorldPos);
        
        vec3 halfVector = normalize(surfaceToLight + surfaceToView);

        float diffFactor = max(dot(normal, surfaceToLight), 0.0);
        float specFactor = 0.0;
        if (diffFactor > 0.0)
            specFactor = pow(max(dot(normal, halfVector), 0.0), 10.0);

        float atten = clamp(1.0 - uLights[i].range * 2.0 / length(surfaceToLightDelta), 0.0, 1.0);
        atten = pow(1.0 - atten, 2.0);

        vec3 amount = (diffColor.rgb * uLights[i].color.rgb * diffFactor +
                        specColor.rgb * specFactor * atten) * uLights[i].color.a * atten;

        lighting.rgb += amount;

    }

    return lighting;
}

#endif

#ifdef FOG
float GetFogFactor(float pos)
{
    float start = uFogParams.x;
    float end = uFogParams.y;

    return 1.0 - clamp(((end - pos) / (end - start)), 0.0, 1.0);
}
#endif

#ifdef NORMALMAP
vec3 UnpackNormal(vec3 packed) {
    return normalize(packed * 2.0 - 1.0);
}
#endif

///////////////////////////////////////////////////////////////////////////////
// Fragment shader

void main()
{
    vec4 diff = uDiffuseColor;

    #ifdef DIFFUSEMAP
        diff *= texture2D(sDiffuseMap, vTexCoord);
    #endif

    #ifdef VERTEX_COLORS
        diff.rgb *= vColor;
    #endif

    #ifdef LIGHTS
        vec4 spec = uSpecularColor;

        #ifdef SPECMAP
            spec.rgb *= texture2D(sSpecularMap, vTexCoord).rgb;
        #endif

        #ifdef NORMALMAP
            vec3 normal = UnpackNormal(texture2D(sNormalMap, vTexCoord).xyz);
            mat3 tbnMatrix = mat3(vTangent, vBitangent, vNormal);

            normal = normalize(tbnMatrix * normal);
        #else
            vec3 normal = normalize(vNormal);
        #endif

        vec4 col = vec4(GetLighting(normal, diff, spec).rgb, diff.a);
    #else
        vec4 col = diff;
    #endif

    #ifdef AMBIENTMAP
        float ambientIntensity = texture2D(sAmbientMap, vTexCoord).r;
        col.rgb += diff.rgb * uAmbientColor.rgb * ambientIntensity;
    #else
        col.rgb += diff.rgb * uAmbientColor.rgb;
    #endif

    #ifdef EMSSIONMAP
        col.rgb += col.rgb * uEmissionMap.r;
    #endif

    #ifdef ENVIRONMENTMAP
        col.rgb += texture(sEnvironmentMap, normalize(reflect(vReflection, normal))).rgb * 0.2;
    #endif

    #ifdef FOG
        col.rgb = mix(col.rgb, uFogColor, GetFogFactor(gl_FragCoord.z / gl_FragCoord.w));
    #endif

    fColor = col;

    #ifdef NORMALMAP
    // fColor.rgb = texture2D(sNormalMap, vTexCoord).xyz;
    #endif
}

#endif
</script>


<script>
// Test run script
function testRun() {
	// Setting up model program and vao is done when model is loaded
	// Model loading starts after gl has been initialized!!!
	engine.models.cube.program = engine.gl.program.default;
	engine.models.cube.vao = webgl.createModelVaoAndBuffers(engine.gl, engine.models.cube);
	// Demo object. Objects refer to a model
	// Transform is a property of a demo object, not a model's
	obj = {};
	obj.model = engine.models.cube;
	
    engine.builtinMesh = {
        "ColorCube": engine.models.cube,
    };
	engine.gl.view = mat4.invert(mat4.translate(0, 0, -5));
	
	// asd();
    sceneTest();
}

function asd() {
	requestAnimationFrame(asd);
	
	obj.transform = mat4.multiply(mat4.rotateY(Date.now() * 0.001), mat4.rotateX(Date.now() * 0.003));
	
	webgl.drawObjectModel(engine.gl, obj);
}

function buildTestMesh(positions, colors, normals, indices) {

    if (positions.length != colors.length || positions.length != normals.length) {
        console.log("Uneven lengths on vertex attributes");
        return null;
    }

    if ((positions.length % 3) != 0) {
        console.log("Vertex attribute lengths not multiply of 3");
        return null;
    }

    let vCount = positions.length / 3;
    let vSize = 9; // sizeof(position) + sizeof(color) + sizeof(normal)

    let vBuff = new Float32Array(vCount * vSize);

    for (let i = 0; i < vCount; ++i) {
        let offset = i * vSize;

        vBuff[offset + 0] = positions[i * 3 + 0];
        vBuff[offset + 1] = positions[i * 3 + 1];
        vBuff[offset + 2] = positions[i * 3 + 2];

        vBuff[offset + 3] = colors[i * 3 + 0];
        vBuff[offset + 4] = colors[i * 3 + 1];
        vBuff[offset + 5] = colors[i * 3 + 2];

        vBuff[offset + 6] = normals[i * 3 + 0];
        vBuff[offset + 7] = normals[i * 3 + 1];
        vBuff[offset + 8] = normals[i * 3 + 2];
    }

    let iBuff = new Uint16Array(indices);

    let attrs = [
        new MeshAttribute("position", 0, 3),
        new MeshAttribute("color", 3, 3),
        new MeshAttribute("normal", 6, 3),
    ];
    

    return Mesh.fromData(vBuff, iBuff, attrs);
}

function displayStatics(performance) {
    let div = document.getElementById("render-statistics");

    let html = 
        "<p>FPS: " + parseInt(performance.fps) + "</p>" +
        "<p>Scene Nodes: " + performance.objects + "</p>" +
        "<p>Vertices: " + performance.vertices + "</p>" +
        "<p>Draw Calls: " + performance.numDrawCalls + "</p>" +
        "<p>Lights: " +     performance.numLights + "</p>" +
        "<p>Batches: " +    performance.batches + "</p>" +
        "<p> bindShader(): " +    performance.bindShader + "</p>" +
        "<p> bindMaterial(): " +  performance.bindMaterial + "</p>"+
        "<p> bindMesh(): " +      performance.bindMesh + "</p>"+
        "<p> bindTexture(): " +   performance.bindTexture + "</p>"+
        "<p> bindLights(): " +    performance.bindLights + "</p>"+
        "<p> bindTransform(): " + performance.bindTransform + "</p>";

    div.innerHTML = html;
}

function random(scale) {
    return ((Math.random() * 2.0) - 1.0) * scale;
}

function spawnCubes(scene, mesh, material, num)
{
    for (let i = 0; i < num; ++i) {
        let cubeNode = scene.createChild("Cube");

        let scale = (0.75 + random(0.7)) * 5.0;

        cubeNode.worldPosition = [ random(50.0), random(50.0), random(50.0) ];
        cubeNode.localScale = [ scale, scale, scale ];

        cubeNode.localRotation = Quaternion.fromEulers(
            random(360.0), random(360.0), random(360.0)
        );

        let cube = cubeNode.createComponent(Model);
        cube.mesh = mesh;
        cube.meshName = mesh.name;

        cube.material = material;
        cube.materialName = "DefaultMaterial";
    }
}


function initInput() {

    let inputKeys = ["w", "a", "s", "d", "e", "q"];

    let input = {
    };

    inputKeys.forEach(function(value) {
        input[value] = false;
    });

    input["MouseX"] = undefined;
    input["MouseY"] = undefined;

    input["MouseDeltaX"] = 0.0;
    input["MouseDeltaY"] = 0.0;

    window.addEventListener("keydown", function(ev) {
        if (ev.key in input) {
            input[ev.key] = true;
        }

    }, false);

    window.addEventListener("keyup", function(ev) {
        if (ev.key in input) {
            input[ev.key] = false;
        }

    }, false);

    window.addEventListener("mousemove", function(ev) {
        if (input["MouseX"] === undefined) {
            input["MouseX"] = ev.screenX;
            input["MouseX"] = ev.screenY;
        }
        else {
            input["MouseDeltaX"] = ev.screenX - input["MouseX"];
            input["MouseDeltaY"] = ev.screenY - input["MouseY"];

            input["MouseX"] = ev.screenX;
            input["MouseY"] = ev.screenY;
        }

    }, false);

    return input;
}

function updateCamera(camNode, timeDelta) {

    let dz = 0.0;
    let dx = 0.0;
    let dy = 0.0;

    if (engine.input["w"]) { dz += 1.0; }
    if (engine.input["s"]) { dz -= 1.0; }

    if (engine.input["d"]) { dx -= 1.0; }
    if (engine.input["a"]) { dx += 1.0; }

    if (engine.input["e"]) { dy -= 1.0; }
    if (engine.input["q"]) { dy += 1.0; }

    const speed = 0.01;

    dz *= timeDelta * speed;
    dx *= timeDelta * speed;
    dy *= timeDelta * speed;

    let d = vec3.add(
        vec3.scale(camNode.forward, dz),
        vec3.scale(camNode.left, dx)
    );

    d = vec3.add(d, vec3.scale(camNode.up, dy));

    camNode.translateLocal(d);

}

function drawOriginAxes(debug, size, opacity=1.0) {
    debug.line([-size,     0,     0], [size,    0,    0], new Color(1, 0, 0, opacity));
    debug.line([    0, -size,     0], [   0, size,    0], new Color(0, 1, 0, opacity));
    debug.line([    0,     0, -size], [   0,    0, size], new Color(0, 0, 1, opacity));
}

function sceneTest() {
    engine.renderer = new Renderer(engine.gl);
    engine.renderer.performance.fps = 0.0;
    engine.input = initInput();

    engine.componentTypes = {
        "Camera": Camera,
        "Light": Light,
        "Model": Model,
    };

    engine.resourceTypes = {
        "Texture": Texture,
        "Material": Material,
        "Mesh": Mesh,
        "JSONFile": JSONFile,
        "TextFile": TextFile,
    };

	engine.resources = new ResourceManager();
    engine.resources.queueForLoading(Mesh, "engine/resources/monkey.obj");
    engine.resources.queueForLoading(Texture, "engine/resources/MonkeyPink.png");
    engine.resources.queueForLoading(JSONFile, "data/scenes/testScene.json");

    engine.resources.queueForLoading(Mesh, "data/models/UVCube.obj");
    engine.resources.queueForLoading(Texture, "data/textures/CubeDiffuse.png");
    engine.resources.queueForLoading(Texture, "data/textures/CubeNormal.png");
    engine.resources.queueForLoading(Texture, "data/textures/CubeSpecular.png");
    
    
    // Debug loading model without uv coordinates
    engine.resources.queueForLoading(Mesh, "data/models/ThreeMaterialCube.obj");
    
    
    let scene = new Scene();
    scene.ambientColor = new Color(0.1, 0.01, 0.01, 1.0);
    scene.fogColor = new Color(0.15, 0.15, 0.15, 1.0);
    scene.fogDistance = 80.0;

    engine.scene = scene;

    let mesh = buildTestMesh(
        engine.models.cube.vertices,
        engine.models.cube.colors,
        engine.models.cube.normals,
        engine.models.cube.indices
    );

    let shader = new ShaderSource("TestShader",
        document.getElementById("test-shader").innerHTML);

    let debugShader = new ShaderSource("DebugShader",
        document.getElementById("debug-shader").innerHTML
    );

    let material = new Material();
    material.shader = shader;
    material.enableDefine("NORMALS");
    material.enableDefine("LIGHTS");

    engine.resources.addBuiltinResource("DefaultMaterial", material);
    engine.resources.addBuiltinResource("ColorCube", mesh);
    engine.resources.addBuiltinResource("DebugShader", debugShader);
	
    engine.resources.onAllLoaded(function() {

        let t = engine.resources.getCached(Texture, "engine/resources/MonkeyPink.png");

        let m = new Material();
        m.shader = shader;

        m.enableDefine("DIFFUSEMAP");
        m.enableDefine("NORMALS");
        m.enableDefine("LIGHTS");
        m.enableDefine("FOG");
        m.enableDefine("ENVIRONMENTMAP");

        m.textures = new Map([
            ["diffuseMap", t]
        ]);

        spawnCubes(scene, engine.resources.getCached(Mesh, "engine/resources/monkey.obj"),
            m, 100);

        let testNode = scene.createChild("Cube");
        testNode.scaleLocal([3, 3, 3]);
        testNode.translateLocal([0, 5, 0]);

        let model = testNode.createComponent(Model);
        model.mesh = engine.resources.getCached(Mesh, "data/models/UVCube.obj");

        m = new Material();
        m.diffuseColor = Color.white;
        m.specularColor = Color.black;
        m.shader = shader;

        m.enableDefine("LIGHTS");
        m.enableDefine("DIFFUSEMAP");
        m.enableDefine("NORMALS");
        m.enableDefine("NORMALMAP");
        m.enableDefine("FOG");
        m.enableDefine("ENVIRONMENTMAP");

        m.textures = new Map([
            ["diffuseMap", engine.resources.getCached(Texture, "data/textures/CubeDiffuse.png")],
            ["normalMap", engine.resources.getCached(Texture, "data/textures/CubeNormal.png")],
        ]);

        model.material = m;
        model.materials[1] = m;

        let envMaps = scene.getAllComponents(EnvironmentMap);
        envMaps.forEach(function(env, index) {
            console.log("Building environment map " + index + "/" + envMaps.length);
            env.build(engine.renderer);
        });
    });

    let debug = new DebugRenderer(engine.gl);
    debug._shader = debugShader;
	
    let cubeNode = scene.createChild("Cube");

    let cube = cubeNode.createComponent(Model);
    cube.mesh = mesh;
    cube.meshName = "ColorCube";
    cube.material = material;
    cube.materialName = "DefaultMaterial";

    let camNode = scene.createChild("Camera");
	camNode.translateLocal([0, 0, -5]);

    let camera = camNode.createComponent(Camera);
    camera.fieldOfView = 90.0;

    let lightRotator = scene.createChild("LightRotator");

    let lightNode = scene.createChild("Light");
    lightNode.localPosition = [30, 30, -30];
    lightNode.setParent(lightRotator);

    let light = lightNode.createComponent(Light);
    light.color = new Color(0.8, 0.8, 0.8, 1.0);

    /*
    lightNode = scene.createChild("Light2");
    lightNode.localPosition = [-30, -30, 30];
    lightNode.setParent(lightRotator);

    light = lightNode.createComponent(Light);
    light.color = new Color(0.1, 1.0, 0.1, 1.2);

    lightNode = scene.createChild("Light3");
    lightNode.localPosition = [30, -30, 30];
    lightNode.setParent(lightRotator);

    light = lightNode.createComponent(Light);
    light.color = new Color(1.0, 0.1, 0.1, 1.2);
    */

    let envmapNode = scene.createChild("EnvironmentMap");
    envmapNode.createComponent(EnvironmentMap);
    envmapNode.translateLocal([0, 20, 0]);

    let prevFrameTime = Date.now();

    requestAnimationFrame(function update() {
        let currentFrameTime = Date.now();
        let timeDelta = currentFrameTime - prevFrameTime;

        let fps = 1.0 / Math.max(timeDelta * 0.001, 0.001);

        requestAnimationFrame(update);

        lightRotator.localRotation = Quaternion.fromEulers(
                Date.now() * 0.0005, Date.now() * 0.0005, Date.now() * 0.0005
        );

        scene.update();
        updateCamera(camNode, timeDelta);

        let renderView = RenderView.fromCamera(camera);

        engine.renderer.resetPerformance();
        engine.renderer.renderScene(scene, renderView);

        debug.dottedCircle([0, 0, 0], 3, vec3.left, Color.magenta);
        debug.cube([0, 0, 0], 5, Color.green, true);
        debug.dottedCircle(lightNode.worldPosition, 1.0, vec3.left, Color.yellow);

        drawOriginAxes(debug, 200, 0.5);

        engine.renderer.renderDebugLines(renderView, debug);
        debug.clear();

        engine.renderer.performance.fps = engine.renderer.performance.fps * 0.99 + fps * 0.01;
        engine.renderer.performance.objects = scene.nodes.size;

        displayStatics(engine.renderer.performance);

        prevFrameTime = currentFrameTime;
    });
}

</script>
